#!/usr/bin/env python3
import code
import os
import re
import subprocess as sp
import time
import zlib
from pathlib import Path

import numpy as np
import pandas as pd
import yaml

DEFAULT_CONFIG = {
    'LogTimestep': 1.0e-6,
    'PowerModelTimestep': 1.0e-6,
    'Board': 'MemicBoard',
    'OutputDirectory': '/tmp/fused-outputs',
    'GdbServer': 'True',
    'SimTimeLimit': 30.0,
    'IoSimulationStopperTarget': 3,
    'EventLogStart': 'simulation_start',
    'CortexM0Version': 'cm0',
    'MasterClockPeriod': 1e-6,
    'PeripheralClockPeriod': 1e-6,
    'CpuCoreVoltage': 1.8,
    'ExtIcc': 25.0e-6,
    'PowerSupply': 'ConstantCurrentSupply',
    'PowerSupplyPower': 2.0e-6,
    'SupplyCurrentLimit': 5.0e-3,
    'SupplyVoltageLimit': 3.59,
    'CapacitorValue': 4.736e-6,
    'CapacitorInitialVoltage': 0.0,
    'BootTracePath': 'N/A',
    'VccMultiplierPath': 'N/A',
    'SVSVon': 1.5,
    'SVSVoff': 1.3,
    'VoltageWarning': 1.2,
    'PMMOn': 1.9,
    'PMMOff': 1.8,
    'VMAX': 3.6,
    'OutputPortTransportDelay': 10e-6,
    'MemicBoard.mcu.icache.Enable': 'False',
    'MemicBoard.mcu.icache.CacheReplacementPolicy': 'PseudoRandom',
    'MemicBoard.mcu.icache.CacheWritePolicy': 'WriteAround',
    'MemicBoard.mcu.icache.CacheLineWidth': 16,
    'MemicBoard.mcu.icache.CacheNLines': 2,
    'MemicBoard.mcu.icache.CacheNSets': 2,
    'MemicBoard.mcu.dcache.Enable': 'False',
    'MemicBoard.mcu.dcache.CacheReplacementPolicy': 'PseudoRandom',
    'MemicBoard.mcu.dcache.CacheWritePolicy': 'WriteBack',
    'MemicBoard.mcu.dcache.CacheLineWidth': 16,
    'MemicBoard.mcu.dcache.CacheNLines': 2,
    'MemicBoard.mcu.dcache.CacheNSets': 2,
    'MemicBoard.mcu.dcache.dcache_ctrl.hardMaxDirty': 9999,
    'MemicBoard.mcu.dcache.dcache_ctrl.softMaxDirty': 9999,
    'MemicBoard.mcu.invm on': 0,
    'MemicBoard.mcu.invm off': 0,
    'MemicBoard.mcu.invm bytes read': 3.52e-12,
    'MemicBoard.mcu.invm bytes written': 9.6e-11,
    'MemicBoard.mcu.dnvm on': 0,
    'MemicBoard.mcu.dnvm off': 0,
    'MemicBoard.mcu.dnvm bytes read': 3.52e-12,
    'MemicBoard.mcu.dnvm bytes written': 9.6e-11,
    'MemicBoard.mcu.sram on': 0,
    'MemicBoard.mcu.sram off': 0,
    'MemicBoard.mcu.sram bytes read': 9.6e-13,
    'MemicBoard.mcu.sram bytes written': 9.6e-13,
    'MemicBoard.mcu.icache on': 0,
    'MemicBoard.mcu.icache off': 0,
    'MemicBoard.mcu.icache bytes read': 9.6e-13,
    'MemicBoard.mcu.icache bytes written': 9.6e-13,
    'MemicBoard.mcu.dcache on': 0.0,
    'MemicBoard.mcu.dcache off': 0.0,
    'MemicBoard.mcu.dcache bytes read': 9.6e-13,
    'MemicBoard.mcu.dcache bytes written': 9.6e-13,
    'MemicBoard.mcu.icache tag access bits': 0.06e-12,
    'MemicBoard.mcu.dcache tag access bits': 0.06e-12,
    'MemicBoard.mcu.CPU on': 4.0e-6,
    'MemicBoard.mcu.CPU off': 0.0,
    'MemicBoard.mcu.CPU sleep': 0.0,
    'MemicBoard.mcu.undoLogger.capacity': 16,
    'MemicBoard.mcu.undoLogger off': 0.0,
    'MemicBoard.mcu.undoLogger enabled': 0.0,
    'MemicBoard.mcu.undoLogger disabled': 0.0,
    'ext.dc': 400.0e-9,
    'Bme280TraceFile': 'none',
    'AccelerometerTraceFile': 'none'
}


class FusedConfig:
    """ FusedConfig: Utility to emit configuration file for fused """
    def __init__(self, baseConfig: str = ""):
        """ Init default config.

        Parameters:
        baseConfig: path to a base config.yaml file to set up default
        parameters.
        """
        if baseConfig == "":
            # Use default config
            self.config = DEFAULT_CONFIG
        else:
            # load base config from file
            self.config = yaml.load(open(baseConfig, 'r').read(),
                                    Loader=yaml.FullLoader)
        self._hash = None
        return

    def get(self, key):
        return self.config[self.getFullKey(key)]

    def set(self, key, value):
        self.config[self.getFullKey(key)] = value
        return

    def setInstructionCacheConfig(self, lineWidth, nLines, nSets):
        self.set('icache.CacheLineWidth', lineWidth)
        self.set('icache.CacheNLines', nLines)
        self.set('icache.CacheNSets', nSets)
        if lineWidth * nLines * nSets == 0:
            self.set('icache.Enable', False)
        return

    def setDataCacheConfig(self, lineWidth, nLines, nSets):
        self.set('dcache.CacheLineWidth', lineWidth)
        self.set('dcache.CacheNLines', nLines)
        self.set('dcache.CacheNSets', nSets)
        if lineWidth * nLines * nSets == 0:
            self.set('dcache.Enable', False)
        return

    def emit(self, path, fn='config.yaml'):
        with open(os.path.join(path, fn), 'w+') as of:
            of.write(
                '# Config file generated by FusedConfig.py\n# {}\n'.format(
                    time.asctime()))
            of.write(self.toString())
        return

    def toString(self):
        result = ''
        for k, v in self.config.items():
            result += '{}: {}\n'.format(k, str(v))
        return result

    def getFullKey(self, key: str) -> str:
        """
        Search the config for a unique entry whos hierarchical name ends with
        key.

        Example:
        self.config = {
            'SuperSensorNode.mcu.icache.reads'  : 1,
            'SuperSensorNode.mcu.icache.writes' : 2,
            'SuperSensorNode.mcu.dcache.reads'  : 3,
            'SuperSensorNode.mcu.dcache.writes' : 4
        }

        getItem('SuperSenorNode.mcu.icache.reads')  -> OK, returns item
        getItem('mcu.icache.reads')                 -> OK, returns item
        getItem('icache.reads')                     -> OK, returns item
        getItem('reads')                            -> Error, not unique
        getItem('rreads')                           -> Error, not found

        """

        nWords = len(key.split('.'))
        foundKeys = []
        for k in self.config.keys():
            if '.'.join(k.split('.')[-nWords:]) == key:
                foundKeys.append(k)

        if len(foundKeys) == 0:
            raise Exception(f'No entries that match Key {key:s} found')
        elif len(foundKeys) > 1:
            raise Exception(
                f'Key {key:s} is not unique, but matches {foundKeys}')
        else:
            return foundKeys[0]

    @property
    def hash(self):
        '''
        Return a hash of this configuration. Computed once to avoid it
        changing.
        '''
        if self._hash is None:
            self._hash = zlib.crc32(self.toString().encode())
        return self._hash


if __name__ == "__main__":
    # Write default/dummy config to /tmp
    fc = FusedConfig('/nope')
    fc.emit('/tmp/')
    exit(0)
